# -*- coding: utf-8 -*-
"""Portafolios_Markowitz_Seminario_de_Finanzas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wBPXyVhldCmX4O0CMKqiT4SLweImzBkk
"""

############################# LIBRERÍAS #######################################
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as op

##### MÉTRICAS QUE SE OCUPAN EN LAS FUNCIONES DE LOS PORTAFOLIOS ###############

# Rendimientos Diarios del Portafolio
def retornos_portafolio_diarios(retornos, pesos):
  # Retornos: Data frame con los rendimientos de cada instrumento financiero que compone al portafolio
  # Pesos: Vector con los pesos de cada instrumento financiero que compone al portafolio
  retornos_portafolio = np.dot(retornos, pesos)
  return retornos_portafolio
# Rendimiento Anual
def retorno_anual_portafolio(r):
  # r = rendimientos diarios del portafolio
  retorno_anual = r.mean() * 252
  return retorno_anual
# Volatilidad Anual del Portafolio
def volatilidad_portafolio(retornos, pesos):
  # Retornos: Data frame con los rendimientos de cada instrumento financiero que compone al portafolio
  # Pesos: Vector con los pesos de cada instrumento financiero que compone al portafolio
  cov = retornos.cov() * 252
  volatilidad = np.sqrt(np.dot(pesos.T, np.dot(cov, pesos)))
  return volatilidad
# Sharpe Ratio
def sharpe_ratio(r, rf = 0.045, periods = 252):
  # r = rendimientos diarios del portafolio
  # rf = Tasa libre de riesgo anual
  rf_rate = (1 + rf)**(1/periods) - 1
  excess = r - rf_rate             # retornos en exceso = R_p - R_f
  mean_excess = np.mean(excess)    # E[R_p - R_f]
  std_excess = np.std(excess)      # desviación estándar σ(R_p - R_f)
  sharpe = np.sqrt(periods) * mean_excess / std_excess
  return sharpe
################################ PORTAFOLIOS ######################################
# Portafolio de Mínima Varianza
def portafolio_minima_varianza(retornos):
  # retrornos: Data frame con los retornos diarios de cada instrumento financiero
  #             (en este caso ETF) que conforman al portafolio.
    # Número de activos
    n = retornos.shape[1]
    # Punto inicial (pesos iguales)
    x0 = np.ones(n) / n
    # No permitir short selling, es decir, la proporción de cada activo debe estár entre 0 y 1
    bounds = tuple((0,1) for _ in range(n))
    # Restricciones
    constraints = ({'type':'eq','fun': lambda w: np.sum(w) - 1})
    result = op.minimize(
        lambda w: volatilidad_portafolio(retornos, w),
        x0,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints
    )
    # Pesos óptimos
    pesos_optimos = result.x
    #Las entradas de la función regresan:
    #     1.- Pesos Óptimos del Portafolio
    #     2.- Retorno Anual del Portafolio
    #     3.- Volatilidad Anual del Portafolio
    return pesos_optimos, retorno_anual_portafolio(retornos_portafolio_diarios(retornos, pesos_optimos)), volatilidad_portafolio(retornos, pesos_optimos)
# Portafolio de Máximo Retorno
def portafolio_maximo_retorno(retornos):
    # retrornos: Data frame con los retornos diarios de cada instrumento financiero
    #             (en este caso ETF) que conforman al portafolio.
    # Número de activos
    n = retornos.shape[1]
    # Punto inicial (pesos iguales)
    x0 = np.ones(n) / n
    # No permitir short selling, es decir, la proporción de cada activo debe estár entre 0 y 1
    bounds = tuple((0,1) for _ in range(n))
    # Restricciones
    constraints = ({'type':'eq','fun': lambda w: np.sum(w) - 1})
    result = op.minimize(
        lambda w: -retorno_anual_portafolio(retornos_portafolio_diarios(retornos, w)),  # negativo para maximizar
        x0,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints
    )
    # Pesos óptimos
    pesos_optimos = result.x

    #Las entradas de la función regresan:
    #     1.- Pesos Óptimos del Portafolio
    #     2.- Retorno Anual del Portafolio
    #     3.- Volatilidad Anual del Portafolio
    return pesos_optimos, retorno_anual_portafolio(retornos_portafolio_diarios(retornos, pesos_optimos)), volatilidad_portafolio(retornos, pesos_optimos)
# Portafolio de Máximo Sharpe
def portafolio_maximo_sharpe(retornos, rf):
    # retrornos: Data frame con los retornos diarios de cada instrumento financiero
    #             (en este caso ETF) que conforman al portafolio.
    # rf: Tasa libre de riesgo
    # Número de activos
    n = retornos.shape[1]
    # Punto inicial (pesos iguales)
    x0 = np.ones(n) / n
    # No permitir short selling, es decir, la proporción de cada activo debe estár entre 0 y 1
    bounds = tuple((0,1) for _ in range(n))
    # Restricciones
    constraints = ({'type':'eq','fun': lambda w: np.sum(w) - 1})
    result = op.minimize(
        lambda w: - sharpe_ratio(retornos_portafolio_diarios(retornos, w), rf=rf),  # negativo para maximizar
        x0,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints
    )
    # Pesos óptimos
    pesos_optimos = result.x

    #Las entradas de la función regresan:
    #     1.- Pesos Óptimos del Portafolio
    #     2.- Retorno Anual del Portafolio
    #     3.- Volatilidad Anual del Portafolio
    return pesos_optimos, retorno_anual_portafolio(retornos_portafolio_diarios(retornos, pesos_optimos)), volatilidad_portafolio(retornos, pesos_optimos)
# Portafolio de Mínima Varianza dado un Retorno Objetivo (Markowitz)
def min_varianza_dado_retorno(retornos, target_return):
    # retrornos: Data frame con los retornos diarios de cada instrumento financiero
    #             (en este caso ETF) que conforman al portafolio.
    # target_return: Retorno Objetivo dado por el Usuario
    # Número de activos
    n = retornos.shape[1]
    # Punto inicial (pesos iguales)
    x0 = np.ones(n) / n
    # Restricciones
    constraints = (
        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},  # suma de pesos = 1
        {'type': 'eq', 'fun': lambda w: retorno_anual_portafolio(retornos_portafolio_diarios(retornos, w)) - target_return}
    )
    # No permitir short selling, es decir, la proporción de cada activo debe estár entre 0 y 1
    bounds = tuple((0, 1) for _ in range(n))
    # Función a minimizar (volatilidad del portafolio)
    def objective(w):
        return volatilidad_portafolio(retornos, w)
    # Optimización
    result = op.minimize(
        objective,
        x0,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints
    )
    # Pesos óptimos
    pesos_optimos = result.x
    # Métricas del portafolio óptimo
    retorno = retorno_anual_portafolio(retornos_portafolio_diarios(retornos, pesos_optimos))
    volatilidad = volatilidad_portafolio(retornos, pesos_optimos)
    #Las entradas de la función regresan:
    #     1.- Pesos Óptimos del Portafolio
    #     2.- Retorno Anual del Portafolio
    #     3.- Volatilidad Anual del Portafolio
    return pesos_optimos, retorno, volatilidad

def black_litterman_portfolio(returns, tau, rf_rate, P, Q, w_m, lam, sum_constraint=True):
    """
    Calcula la asignación óptima de activos usando el modelo Black-Litterman.
    
    Parámetros:
    -----------
    returns : array-like (n_assets, n_days) o (n_days, n_assets)
        Rendimientos históricos diarios de los activos
    tau : float
        Parámetro de escala de la incertidumbre (generalmente entre 0.01 y 0.05)
    rf_rate : float
        Tasa libre de riesgo diaria
    P : array-like (n_views, n_assets)
        Matriz de selección de views
    Q : array-like (n_views,)
        Vector de valores esperados de las views
    lam : float
        Coeficiente de aversión al riesgo
    sum_constraint : bool
        Si True, los pesos suman 1; si False, no hay restricción de suma
        
    Retorna:
    --------
    w_optimal : numpy array
        Pesos óptimos del portafolio
    posterior_returns : numpy array
        Retornos esperados posteriores de Black-Litterman
    """
    # Asegurar que returns sea un array numpy
    returns = np.array(returns)
    # Si returns tiene forma (n_days, n_assets), transponer
    if returns.shape[0] > returns.shape[1]:
        returns = returns.T
    n_assets = returns.shape[0]
    # 1. Calcular retornos medios históricos (Π) y matriz de covarianza (Σ)
    # Π = retornos excedentes históricos (sobre tasa libre de riesgo)
    # historical_mean = np.mean(returns, axis=1)
    # Calcular matriz de covarianza Σ
    Sigma = np.cov(returns)
    # Calcular Π = λΣw_M
    Pi = lam * (Sigma @ w_m)
    # 2. Calcular Ω (matriz de covarianza de las views)
    # Ω = P * (τΣ) * P^T
    Omega = P @ (tau * Sigma) @ P.T
    # Asegurar que Ω sea invertible (añadir pequeña diagonal si es necesario)
    if np.linalg.matrix_rank(Omega) < Omega.shape[0]:
        Omega += np.eye(Omega.shape[0]) * 1e-6
    Omega = np.diag(np.diag(Omega))
    # 3. Calcular el inverso de (τΣ)
    tau_Sigma_inv = np.linalg.inv(tau * Sigma)
    # 4. Calcular retornos posteriores esperados (fórmula de Black-Litterman)
    # R_posterior = [(τΣ)^-1 + P'Ω^-1P]^-1 * [(τΣ)^-1Π + P'Ω^-1Q]
    P_T = P.T
    # Primera parte: [(τΣ)^-1 + P'Ω^-1P]
    Omega_inv = np.linalg.inv(Omega)
    first_part = tau_Sigma_inv + P_T @ Omega_inv @ P
    # Segunda parte: [(τΣ)^-1Π + P'Ω^-1Q]
    second_part = tau_Sigma_inv @ Pi + P_T @ Omega_inv @ Q
    # Calcular retornos posteriores
    posterior_returns = np.linalg.inv(first_part) @ second_part
    # 5. Calcular asignación óptima de activos
    if not sum_constraint:
        # Sin restricción de suma (fórmula 42)
        w_optimal = (1/lam) * np.linalg.inv(Sigma) @ posterior_returns
    else:
        # Con restricción de que los pesos sumen 1
        # Usamos optimización como en el ejemplo de Markowitz
        # Función objetivo: maximizar utility = w'*R - (λ/2)*w'Σw
        def objective(w):
            utility = w @ posterior_returns - (lam/2) * (w @ Sigma @ w.T)
            return -utility  # Negativo porque minimize() minimiza
        # Condiciones iniciales (pesos iguales)
        x0 = np.ones(n_assets) / n_assets
        # Restricciones
        constraints = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})
        # Límites (sin ventas cortas)
        bounds = tuple((0, 1) for _ in range(n_assets))
        # Optimización
        result = op.minimize(objective, x0, constraints=constraints, 
                         bounds=bounds, method='trust-constr',tol=1e-25)
        
        w_optimal = result.x
    
    return w_optimal, posterior_returns

"""
def black_litterman_portfolio_02(returns, tau, rf_rate, P, Q, lam, w_M=None, 
                                sum_constraint=True, 
                                method='SLSQP', use_equilibrium=True):
    
    Black-Litterman con opción de usar retornos de equilibrio Π = λΣw_M
    
    Parámetros:
    -----------
    returns : array (n_assets, n_days) o (n_days, n_assets)
        Rendimientos históricos
    tau : float
        Parámetro de incertidumbre
    rf_rate : float
        Tasa libre de riesgo
    P : array (n_views, n_assets)
        Matriz de views
    Q : array (n_views,)
        Retornos esperados de las views
    lam : float
        Coeficiente de aversión al riesgo
    w_M : array (n_assets,), opcional
        Pesos del benchmark (market portfolio). Si es None, se calculan automáticamente.
    view_confidences : array (n_views,) o float, opcional
        Confianzas en las views (0-1)
    sum_constraint : bool
        Si True, los pesos suman 1
    method : str
        Método de optimización
    use_equilibrium : bool
        Si True, usa Π = λΣw_M; si False, usa retornos históricos
    
    Retorna:
    --------
    w_optimal : array
        Pesos óptimos
    posterior_returns : array
        Retornos posteriores
    Pi : array
        Retornos de equilibrio/históricos usados
    
    # Procesar returns
    returns = np.array(returns)
    if returns.shape[0] > returns.shape[1]:
        returns = returns.T
    
    n_assets = returns.shape[0]
    
    # Calcular matriz de covarianza
    Sigma = np.cov(returns)
    
    # 1. Calcular Π (retornos de equilibrio o históricos)
    if use_equilibrium:
        # Método 1: Π = λΣw_M (equilibrio CAPM)
        if w_M is None:
            # Si no hay w_M, usar pesos del mercado (proporcionales a capitalización)
            # Alternativa: usar pesos iguales
            w_M = np.ones(n_assets) / n_assets
        
        # Asegurar que w_M sea array numpy
        w_M = np.array(w_M)
        
        # Verificar que w_M tenga dimensión correcta
        if len(w_M) != n_assets:
            raise ValueError(f"w_M debe tener {n_assets} elementos, tiene {len(w_M)}")
        
        # Verificar que los pesos sumen aproximadamente 1
        if abs(np.sum(w_M) - 1.0) > 0.01:
            st.warning(f"Los pesos de w_M no suman 1 (suma={np.sum(w_M):.4f}). Normalizando...")
            w_M = w_M / np.sum(w_M)
        
        # Calcular Π = λΣw_M
        Pi = lam * (Sigma @ w_M)
        
        # Explicación para debugging
        print(f"Usando Π de equilibrio:")
        print(f"  λ = {lam}")
        print(f"  w_M = {w_M}")
        print(f"  Π = λΣw_M = {Pi}")
        
    else:
        # Método 2: Π = retornos históricos promedio (exceso)
        historical_mean = np.mean(returns, axis=1)
        Pi = historical_mean - rf_rate
        print(f"Usando Π histórico: {Pi}")
    
    # 2. Calcular Ω (matriz de covarianza de las views)
    
    # Ω = P * (τΣ) * P^T
    Omega = P @ (tau * Sigma) @ P.T
    # Asegurar que Ω sea invertible (añadir pequeña diagonal si es necesario)
    if np.linalg.matrix_rank(Omega) < Omega.shape[0]:
        Omega += np.eye(Omega.shape[0]) * 1e-6
    Omega = np.diag(np.diag(Omega))
    
    # 3. Calcular retornos posteriores (fórmula Black-Litterman)
    tau_Sigma_inv = np.linalg.inv(tau * Sigma)
    P_T = P.T
    Omega_inv = np.linalg.inv(Omega)
    
    first_part = tau_Sigma_inv + P_T @ Omega_inv @ P
    second_part = tau_Sigma_inv @ Pi + P_T @ Omega_inv @ Q
    
    posterior_returns = np.linalg.inv(first_part) @ second_part
    
    # 4. Calcular asignación óptima
    if not sum_constraint:
        w_optimal = (1/lam) * np.linalg.inv(Sigma) @ posterior_returns
    else:
        def objective(w):
            utility = w @ posterior_returns - (lam/2) * (w @ Sigma @ w.T)
            return -utility
        
        x0 = np.ones(n_assets) / n_assets
        constraints = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})
        bounds = tuple((0, 1) for _ in range(n_assets))
        
        result = op.minimize(
            objective, x0, constraints=constraints, 
            bounds=bounds, method=method,
            options={'ftol': 1e-10, 'maxiter': 1000, 'disp': False}
        )
        
        w_optimal = result.x
        
        if not result.success:
            print(f"Optimización no convergió: {result.message}")
            w_optimal = np.ones(n_assets) / n_assets
    
    return w_optimal, posterior_returns, Pi

"""