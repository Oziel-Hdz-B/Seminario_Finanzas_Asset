# -*- coding: utf-8 -*-
"""Portafolios_Markowitz_Seminario_de_Finanzas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wBPXyVhldCmX4O0CMKqiT4SLweImzBkk
"""

############################# LIBRERÍAS #######################################
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as op

##### MÉTRICAS QUE SE OCUPAN EN LAS FUNCIONES DE LOS PORTAFOLIOS ###############

# Rendimientos Diarios del Portafolio
def retornos_portafolio_diarios(retornos, pesos):
  # Retornos: Data frame con los rendimientos de cada instrumento financiero que compone al portafolio
  # Pesos: Vector con los pesos de cada instrumento financiero que compone al portafolio
  retornos_portafolio = np.dot(retornos, pesos)
  return retornos_portafolio
# Rendimiento Anual
def retorno_anual_portafolio(r):
  # r = rendimientos diarios del portafolio
  retorno_anual = r.mean() * 252
  return retorno_anual
# Volatilidad Anual del Portafolio
def volatilidad_portafolio(retornos, pesos):
  # Retornos: Data frame con los rendimientos de cada instrumento financiero que compone al portafolio
  # Pesos: Vector con los pesos de cada instrumento financiero que compone al portafolio
  cov = retornos.cov() * 252
  volatilidad = np.sqrt(np.dot(pesos.T, np.dot(cov, pesos)))
  return volatilidad
# Sharpe Ratio
def sharpe_ratio(r, rf = 0.045, periods = 252):
  # r = rendimientos diarios del portafolio
  # rf = Tasa libre de riesgo anual
  rf_rate = (1 + rf)**(1/periods) - 1
  excess = r - rf_rate             # retornos en exceso = R_p - R_f
  mean_excess = np.mean(excess)    # E[R_p - R_f]
  std_excess = np.std(excess)      # desviación estándar σ(R_p - R_f)
  sharpe = np.sqrt(periods) * mean_excess / std_excess
  return sharpe
################################ PORTAFOLIOS ######################################
# Portafolio de Mínima Varianza
def portafolio_minima_varianza(retornos):
  # retrornos: Data frame con los retornos diarios de cada instrumento financiero
  #             (en este caso ETF) que conforman al portafolio.
    # Número de activos
    n = retornos.shape[1]
    # Punto inicial (pesos iguales)
    x0 = np.ones(n) / n
    # No permitir short selling, es decir, la proporción de cada activo debe estár entre 0 y 1
    bounds = tuple((0,1) for _ in range(n))
    # Restricciones
    constraints = ({'type':'eq','fun': lambda w: np.sum(w) - 1})
    result = op.minimize(
        lambda w: volatilidad_portafolio(retornos, w),
        x0,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints
    )
    # Pesos óptimos
    pesos_optimos = result.x
    #Las entradas de la función regresan:
    #     1.- Pesos Óptimos del Portafolio
    #     2.- Retorno Anual del Portafolio
    #     3.- Volatilidad Anual del Portafolio
    return pesos_optimos, retorno_anual_portafolio(retornos_portafolio_diarios(retornos, pesos_optimos)), volatilidad_portafolio(retornos, pesos_optimos)
# Portafolio de Máximo Retorno
def portafolio_maximo_retorno(retornos):
    # retrornos: Data frame con los retornos diarios de cada instrumento financiero
    #             (en este caso ETF) que conforman al portafolio.
    # Número de activos
    n = retornos.shape[1]
    # Punto inicial (pesos iguales)
    x0 = np.ones(n) / n
    # No permitir short selling, es decir, la proporción de cada activo debe estár entre 0 y 1
    bounds = tuple((0,1) for _ in range(n))
    # Restricciones
    constraints = ({'type':'eq','fun': lambda w: np.sum(w) - 1})
    result = op.minimize(
        lambda w: -retorno_anual_portafolio(retornos_portafolio_diarios(retornos, w)),  # negativo para maximizar
        x0,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints
    )
    # Pesos óptimos
    pesos_optimos = result.x

    #Las entradas de la función regresan:
    #     1.- Pesos Óptimos del Portafolio
    #     2.- Retorno Anual del Portafolio
    #     3.- Volatilidad Anual del Portafolio
    return pesos_optimos, retorno_anual_portafolio(retornos_portafolio_diarios(retornos, pesos_optimos)), volatilidad_portafolio(retornos, pesos_optimos)
# Portafolio de Máximo Sharpe
def portafolio_maximo_sharpe(retornos, rf):
    # retrornos: Data frame con los retornos diarios de cada instrumento financiero
    #             (en este caso ETF) que conforman al portafolio.
    # rf: Tasa libre de riesgo
    # Número de activos
    n = retornos.shape[1]
    # Punto inicial (pesos iguales)
    x0 = np.ones(n) / n
    # No permitir short selling, es decir, la proporción de cada activo debe estár entre 0 y 1
    bounds = tuple((0,1) for _ in range(n))
    # Restricciones
    constraints = ({'type':'eq','fun': lambda w: np.sum(w) - 1})
    result = op.minimize(
        lambda w: - sharpe_ratio(retornos_portafolio_diarios(retornos, w), rf=rf),  # negativo para maximizar
        x0,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints
    )
    # Pesos óptimos
    pesos_optimos = result.x

    #Las entradas de la función regresan:
    #     1.- Pesos Óptimos del Portafolio
    #     2.- Retorno Anual del Portafolio
    #     3.- Volatilidad Anual del Portafolio
    return pesos_optimos, retorno_anual_portafolio(retornos_portafolio_diarios(retornos, pesos_optimos)), volatilidad_portafolio(retornos, pesos_optimos)
# Portafolio de Mínima Varianza dado un Retorno Objetivo (Markowitz)
def min_varianza_dado_retorno(retornos, target_return):
    # retrornos: Data frame con los retornos diarios de cada instrumento financiero
    #             (en este caso ETF) que conforman al portafolio.
    # target_return: Retorno Objetivo dado por el Usuario
    # Número de activos
    n = retornos.shape[1]
    # Punto inicial (pesos iguales)
    x0 = np.ones(n) / n
    # Restricciones
    constraints = (
        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},  # suma de pesos = 1
        {'type': 'eq', 'fun': lambda w: retorno_anual_portafolio(retornos_portafolio_diarios(retornos, w)) - target_return}
    )
    # No permitir short selling, es decir, la proporción de cada activo debe estár entre 0 y 1
    bounds = tuple((0, 1) for _ in range(n))
    # Función a minimizar (volatilidad del portafolio)
    def objective(w):
        return volatilidad_portafolio(retornos, w)
    # Optimización
    result = op.minimize(
        objective,
        x0,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints
    )
    # Pesos óptimos
    pesos_optimos = result.x
    # Métricas del portafolio óptimo
    retorno = retorno_anual_portafolio(retornos_portafolio_diarios(retornos, pesos_optimos))
    volatilidad = volatilidad_portafolio(retornos, pesos_optimos)
    #Las entradas de la función regresan:
    #     1.- Pesos Óptimos del Portafolio
    #     2.- Retorno Anual del Portafolio
    #     3.- Volatilidad Anual del Portafolio
    return pesos_optimos, retorno, volatilidad