# -*- coding: utf-8 -*-
"""Métricas_Portafolio_Proyecto_Seminario_Finanzas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NrfA8YzoJ776GKZlfVe0gSqOk2vs0l4A
"""

# Rendimientos Diarios del Portafolio
def retornos_portafolio_diarios(retornos, pesos):
  # Retornos: Data frame con los rendimientos de cada instrumento financiero que compone al portafolio
  # Pesos: Vector con los pesos de cada instrumento financiero que compone al portafolio

  retornos_portafolio = np.dot(retornos, pesos)
  return retornos_portafolio

# Rendimiento Anual
def retorno_anual_portafolio(r):
  # r = rendimientos diarios del portafolio

  retorno_anual = r.mean() * 252
  return retorno_anual

# Volatilidad Anual del Portafolio
def volatilidad_portafolio(retornos, pesos):
  # Retornos: Data frame con los rendimientos de cada instrumento financiero que compone al portafolio
  # Pesos: Vector con los pesos de cada instrumento financiero que compone al portafolio

  cov = retornos.cov() * 252
  volatilidad = np.sqrt(np.dot(pesos.T, np.dot(cov, pesos)))
  return volatilidad

# Sharpe Ratio
def sharpe_ratio(r, rf = 0.045, periods = 252):
  # r = rendimientos diarios del portafolio
  # rf = Tasa libre de riesgo anual

  rf_rate = (1 + rf)**(1/252) - 1
  excess = r - rf_rate             # retornos en exceso = R_p - R_f
  mean_excess = np.mean(excess)    # E[R_p - R_f]
  std_excess = np.std(excess)      # desviación estándar σ(R_p - R_f)
  sharpe = np.sqrt(periods) * mean_excess / std_excess
  return sharpe

# Sortino Ratio
def sortino_ratio(r, rf = 0.045, target = 0, periods = 252):
  # r = Rendimientos diarios del portafolio
  # rf = Tasa libre de riesgo anual
  # target = Rendimiento Objetivo
  # periods = Número de días a considerar por año

  rf_rate = (1 + rf)**(1/252) - 1
  excess = r - rf_rate                  # retornos sobre libre de riesgo
  downside = r[r < target] - target     # solo pérdidas respecto al objetivo
  downside_std = np.sqrt(np.mean(downside**2))  # desviación a la baja σ_d
  mean_excess = np.mean(excess)
  sortino = np.sqrt(periods) * mean_excess / downside_std
  return sortino

# Treynor Ratio y Beta
def treynor_ratio(r, benchmark, rf_rate= 0.045, periods=252):
    # r: retornos del portafolio
    # benchmark: retornos del índice de referencia (p.ej. S&P500)
    # rf_rate: tasa libre de riesgo
    # periods = Número de días a considerar por año

    # Convertimos los retornos del portafolio a una serie de pandas para alinearlo con el índice del benchmark
    r_p_series = pd.Series(r, index=retornos.index, name='portfolio_returns')

    # Convertimos la tasa libre de riesgo anualizada a diaria
    rf_diario = (1 + rf_rate)**(1/252) - 1

    # Alineamos los retornos del benchmark y el portafolio basados en su índice común
    # benchmark.iloc[:, 0] asegura que estamos trabajando con la serie de los retornos del benchmark
    aligned_data = pd.DataFrame({'portfolio': r_p_series, 'benchmark': benchmark.iloc[:, 0]})
    aligned_data.dropna(inplace=True) #Arroja cualquier renglón donde no haya datos tanto del portafolio o del benchmark

    exceso_p = aligned_data['portfolio'] - rf_diario
    exceso_b = aligned_data['benchmark'] - rf_diario
    # Calcula la beta usando  los excesos alineados de los retornos
    # np.cov espera matrices 1-D que representan las variables si quieres su covarianza
    beta = np.cov(exceso_p, exceso_b)[0,1] / np.var(exceso_b)

    treynor = exceso_p.mean() * 252 / beta
    return treynor, beta

# Information Ratio
def information_ratio(r, benchmark, periods=252):
  # r: retornos del portafolio
  # benchmark: retornos del índice de referencia
  # periods = Número de días a considerar por año

  # Convertir el array de NumPy de retornos del portafolio a una Serie de Pandas,
  # usando el índice original del DataFrame de retornos
  r_p_series = pd.Series(r, index=retornos.index, name='portfolio_returns')

  # Asegurar que el benchmark sea tratado como una Serie
  benchmark_series = benchmark.iloc[:, 0].rename('benchmark_returns')

  # Crear un nuevo DataFrame para alinear los retornos del portafolio y benchmark por su índice
  aligned_data = pd.DataFrame({'portfolio': r_p_series, 'benchmark': benchmark_series})
  # Eliminar cualquier fila donde falten datos para el portafolio o benchmark después de la alineación
  aligned_data.dropna(inplace=True)

  # Calcular el retorno activo (retorno del portafolio - retorno del benchmark) con los datos alineados
  active = aligned_data['portfolio'] - aligned_data['benchmark']

  # Calcular el Ratio de Información (anualizado)
  # IR = (Media de los Retornos Activos) / (Desviación Estándar de los Retornos Activos) * sqrt(252)
  ir = np.sqrt(periods) * np.mean(active) / np.std(active)
  return ir

# Max drawdown
def max_drawdown(r):
    # r = retornos_diarios_del_portafolio

    acumulado = np.cumprod(1 + r) #DUDA: No sé si se hace sobre los rendimientos acumulados o sobre el precio actual
    maximo = np.maximum.accumulate(acumulado)
    drawdown = (acumulado - maximo) / maximo
    return drawdown.min()

# Calmar Ratio
def calmar_ratio(r):
    # r = retornos_portafolio_diarios

    acumulado = np.cumprod(1 + r)
    maximo = np.maximum.accumulate(acumulado)
    drawdown = (acumulado - maximo) / maximo
    max_dd = abs(drawdown.min())
    cagr = (acumulado[-1])**(252 / len(r)) - 1
    calmar = cagr / max_dd
    return calmar

# Sesgo
def sesgo_portafolio(r):
    # r = retornos_portafolio_diarios

    sesgo = st.skew(r)
    return sesgo

# Curtosis
def curtosis_portafolio(r):
    # r = retornos_portafolio_diarios

    curtosis = st.kurtosis(r)
    return curtosis

# VaR Histórico
def var_historico(r, alpha=0.95):
    # r = retornos_portafolio_diarios(retornos, pesos)

    VaR = np.quantile(r, 1 - alpha)
    return VaR, alpha

# CVaR Histórico
def cvar_historico(r, alpha=0.95):
    # r = retornos_portafolio_diarios

    VaR = np.quantile(r, 1 - alpha)
    CVaR = r[r <= VaR].mean()
    return CVaR, alpha